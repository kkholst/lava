`getPath` <- function(x, ...) UseMethod("getPath")

`getPath.plvmfit` <- function(x, names = NULL, getCoef, getLambda, rm.duplicated = FALSE, ascending = TRUE, order = "lambda1", row = NULL) {
  
  if(isPath(x)){
    stop("getPath.plvmfit: no penalization path in the plvmfit object \n",
         "set argument \'regularizationPath\' to 1 or 2 when calling estimate \n")
  }
  
  if(order %in% c("lambda1","lambda2","lambda1.abs","lambda2.abs") == FALSE){
    stop("getPath.plvmfit: order must be one of \"lambda1\" \"lambda2\" \"lambda1.abs\" \"lambda2.abs\" \n",
         "proposed value: ",paste(order, collapse = " ")," \n")
  }
  
  
  if(!missing(getCoef) && !is.null(getCoef)){
    if(length(getCoef)>1){stop("getPath.plvmfit: getCoef must have length 1 \n")}
    if(getCoef %in% c("coef0", "coefn0")){rm.duplicated <- TRUE}
  }
  
  regPath <- x$regularizationPath
  if(rm.duplicated == 1){ # only keep points where there is a change in the non 0 coefficients (+ first and last knot)
    indexChange <- regPath$indexChange
    indexChange[is.na(indexChange)] <- -1
    test.change <- which(diff(na.omit(indexChange))!=0)+1
    index <- sort(union(c(1,NROW(regPath)),intersect(which(!is.na(regPath$indexChange)), test.change)))
    regPath <- regPath[index, ,drop = FALSE]
  }
   
  if(ascending == TRUE){
    regPath <- regPath[order(regPath[,order], decreasing = FALSE),,drop = FALSE]
  }else{
    regPath <- regPath[order(regPath[,order], decreasing = TRUE),,drop = FALSE]
  }
  validNames <- names(regPath)
  
  if(!is.null(names)){
    
    if(all(names %in% validNames)){
      res <- regPath[,names,drop = FALSE]
    }else{
      stop("getPath.plvmfit: ",names," contains invalid names \n",
           "invalid names: ",paste(names[names %in% validNames == FALSE], collapse = "\" \""),"\n",
           "valid names: ",paste(validNames, collapse = "\" \""),"\n")
    }
    
  } else {
    
    if(missing(getLambda)){
      names.lambda <- c("lambda1.abs", "lambda1", "lambda2.abs", "lambda2")
    }else if(is.null(getLambda)){
      names.lambda <- NULL
    }else{
      validValues <- c("abs", "nabs", "lambda1", "lambda2", "lambda1.abs", "lambda2.abs")
      if(any(getLambda %in% validValues == FALSE)){
        stop("getPath.plvmfit: invalid value for \'getLambda\' \n",
             "getLambda: ",getLambda,"\n",
             "valid values: ",paste(validValues, collapse = "\" \""),"\n")
      }
      
      names.lambda <- sapply(getLambda, function(x){
        switch(x,
               "abs" = c("lambda1.abs", "lambda2.abs"),
               "nabs" = c("lambda1", "lambda2"),
               "lambda1" = c("lambda1"),
               "lambda2" = c("lambda2"),
               "lambda1.abs" = c("lambda1.abs"),
               "lambda2.abs" = c("lambda2.abs")
        )
      })
    }
    
    if(missing(getCoef)){
      names.coef <- setdiff(validNames, c("lambda1.abs", "lambda1", "lambda2.abs", "lambda2", "indexChange"))
    }else if(is.null(getCoef)){
      names.coef <- NULL
    }else if(getCoef %in% c("coef0","coefn0")){
      
      coefChange <- names(regPath)[regPath$indexChange+5] # 5 corresponds to the five colums "lambda1.abs", "lambda1", "lambda2.abs", "lambda2", "indexChange"
      if(0 %in% regPath$lambda1.abs){
        current.coef <- intersect(validNames, x$penalty$name.coef)
        seqIterator <- 1:NROW(regPath)
      }else{
        current.coef <- NULL
        seqIterator <- NROW(regPath):1
      }
     
      ls.coef <- NULL
      for(iterPath in seqIterator){
        if(!is.na(coefChange[iterPath])){
          if(coefChange[iterPath] %in% current.coef){
            current.coef <- setdiff(current.coef, coefChange[iterPath])
          }else{
            current.coef <- union(current.coef, coefChange[iterPath])
          }
        }
        
        if(getCoef == "coefn0"){
          update <- current.coef
        }else{
          update <- setdiff(x$penalty$name.coef,current.coef)
        }
        
        ## add names
        if(!is.null(update)){
          attr(update, "row") <- rownames(regPath)[iterPath]
          if(length(names.lambda)>0){
            for(iterN in names.lambda){
              attr(update, iterN) <- regPath[iterPath,iterN]
            } 
          }
        }
        ls.coef <- c(ls.coef, list(update))
      }
      
      if(0 %in% regPath$lambda1.abs == FALSE){ls.coef <- rev(ls.coef)}
      return(ls.coef)
            
    } else {
      validValues <- c("penalized", "npenalized", "n.coef0", "n.coefn0", "coef0", "coefn0")
      if(getCoef %in% validValues == FALSE){
        stop("getPath.plvmfit: invalid value for \'getCoef\' \n",
             "getCoef: ",getCoef,"\n",
             "valid values: ",paste(validValues, collapse = "\" \""),"\n")
      }
      
      names.penalized <- intersect(validNames, x$penalty$name.coef)
      
      names.coef <- switch(getCoef,
                           "penalized" = names.penalized,
                           "npenalized" = setdiff(names(coef(x)),names.penalized),
                           "n.coef0" = {regPath$coef0 <- rowSums(abs(regPath[,names.penalized, drop = FALSE] == 0)) ; "n.coef0"},
                           "n.coefn0" = {regPath$coefn0 <- rowSums(abs(regPath[,names.penalized, drop = FALSE] != 0)) ; "n.coefn0"}
      )
      
    }
    res <- regPath[,c(names.lambda, names.coef),drop = FALSE]
  }
    
  if(is.null(row)){
    return(res)
  }else if(is.numeric(row)){
    return(res[row,,drop = FALSE])
  }else if(is.character(row)){
    return(res[rownames(res) %in% row,,drop = FALSE])
  }
}

`setPath<-` <- function (x, ..., value) {
  UseMethod("setPath<-", x)
}

`setPath<-.plvmfit` <- function(x, row = NULL, names = NULL, value) {
  
  if(is.null(names)){
    names.value <- names(value)
    
    if(length(names.value)>0){
      names <- names(value)  
    }else{
      stop("setPath<-: argument names must be specified \n")
    }
  }
  
  if(is.null(row)){
    x$regularizationPath[, names] <- value
  }else{
    x$regularizationPath[row, names] <- value
  }
  
  return(x)
}

`getLambda` <- function(x, ...) UseMethod("getLambda")

`getLambda.plvmfit` <- function(x, lambda1 = TRUE, lambda2 = FALSE, abs = TRUE) {
  
  name <- NULL
  if(lambda1){name <- c(name, "lambda1")}
  if(lambda2){name <- c(name, "lambda2")}
  if(abs){name <- paste(name, "abs", sep = ".")}
  return(getPath(x, names = name))
 
}

`isPath` <- function(x, ...) UseMethod("isPath")

`isPath.plvmfit` <- function(x) {
  
  return( is.null(x$regularizationPath) )
  
}







# 
# ### smooth path
# regPath <- x$regularizationPath
# n.coef0 <- rowSums(abs(regPath[,x$penalty$name.coef, drop = FALSE] == 0))
# nmax.coef0 <- max(nCoef)
# 
# nCoefChange <- sapply(seq(0, n.coef0), function(x){which(nCoef==x)[1]})
# diffCoef <- diff(nCoef)
# lambda <- regPath$lambda1.abs
# diffLambda <- diff(lambda)
# 
# if(any(diffLambda == 0)){
#   
#   indexdiffLambda0 <- which(diffLambda == 0)
#   iterIndex <- 1
#   
#   while(iterIndex <= length(indexdiffLambda0)){
#     
#     test.smallLambda <- diffLambda[indexdiffLambda0[iterIndex]+1]
#     test.reverse <- diffCoef[indexdiffLambda0[iterIndex]+1] == - diffCoef[indexdiffLambda0[iterIndex]]
#     if(test.smallLambda && test.reverse){
#       lambda[indexdiffLambda0[iterIndex]+1]
#       regPath[-(indexdiffLambda0[iterIndex]+2),]
#     }
#     
#     
#     
#   }
#   
#   
#   
#   for(iterIndex in nCoefChange){
#     
#   }
#   
#   cond2 <- diffCoef
# }
