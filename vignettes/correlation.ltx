%\VignetteIndexEntry{Manipulation of data-frame data with dutility functions}
%\VignetteEngine{R.rsp::tex}
%\VignetteKeyword{R}
%\VignetteKeyword{package}
%\VignetteKeyword{vignette}
%\VignetteKeyword{LaTeX}
\PassOptionsToPackage{usenames}{xcolor}
\PassOptionsToPackage{hidelinks,colorlinks,linkcolor={blue!50!black},urlcolor={blue!50!black},citecolor={blue!50!black}}{hyperref}
\documentclass[a4paper,12pt]{article}
\usepackage{a4wide}
\usepackage{tikz}

\usepackage{etex}
\usepackage{etoolbox}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathtools,amssymb}
\usepackage[strict=true]{csquotes}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{multicol}
\usepackage{longtable}
\usepackage{zlmtt}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{verbatim}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage[left=2.5cm,top=4cm,right=2.5cm,bottom=4cm]{geometry}
\usepackage{xspace}
\usepackage{url}
\usepackage{amsthm}
\newtheorem{thm}{Theorem.}
\newtheorem{prop}{Proposition.}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition.}
\newtheorem{exa}[thm]{Example}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Real}{\ensuremath{\mathbb{R}}}
\newcommand{\Complex}{\ensuremath{\mathbb{C}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\norm}[1]{\ensuremath{\left\Vert#1\right\Vert}}
\newcommand{\var}{\ensuremath{\mathbb{V}\text{ar}}}
\newcommand{\cov}{\ensuremath{\mathbb{C}\text{ov}}}
\newcommand{\cor}{\ensuremath{\mathbb{C}\text{or}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\pr}{\ensuremath{\mathbb{P}}}
\newcommand{\from}{\leftarrow}
\newcommand{\To}[2]{\ensuremath{#1\!\to\!#2}}
\newcommand{\From}[2]{\ensuremath{#1\!\from\!#2}}
\newcommand{\chain}[3]{\ensuremath{#1\!\to\!#2\to\!#3}}
\newcommand{\ichain}[3]{\ensuremath{#1\!\from\!#2\from\!#3}}
\newcommand{\fork}[3]{\ensuremath{#1\!\from\!#2\to\!#3}}
\newcommand{\ifork}[3]{\ensuremath{#1\!\to\!#2\from\!#3}}
\newcommand{\pa}{\text{pa}}
\newcommand{\abs}[1]{\ensuremath{\left\vert#1\right\vert}}
\newcommand{\ipr}[1]{\langle#1\rangle}
\newcommand{\set}[1]{\left{#1\right}}
\newcommand{\seq}[1]{\left<#1\right>}
\renewcommand{\subset}{\subseteq}
\renewcommand{\supset}{\supseteq}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\mvec}{vec}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\bias}{bias}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\logit}{logit}
\DeclareMathOperator{\expit}{expit}
\makeatletter
 \def\mathcolor#1#{\@mathcolor{#1}}
 \def\@mathcolor#1#2#3{%
   \protect\leavevmode
   \begingroup
     \color#1{#2}#3%
  \endgroup
 }
\newcommand{\Dto}{\overset{\mathcal{D}}{\longrightarrow}}
\newcommand{\Pto}{\overset{P}{\longrightarrow}}
\newcommand{\Wto}{\overset{W}{\longrightarrow}}
\newcommand{\VV}{\bm{\Omega}_\theta}
\newcommand{\independenT}[2]{\mathrel{\setbox0\hbox{$#1#2$}\copy0\kern-\wd0\mkern4mu\box0}}
\newcommand{\indep}{\protect\mathpalette{\protect\independenT}{\perp}}
\DefineVerbatimEnvironment{verbatim}{Verbatim}{xleftmargin=0.5em,xrightmargin=0em,numbers=none,frame=none,fontsize=\footnotesize,formatcom={\color[rgb]{0.2,0.2,0.2}}}
\setlength{\parindent}{0pt} % Kills annoying indents.
\let\iint\relax
\let\iiint\relax

\lstset{basicstyle=\ttfamily\small,keywordstyle=\color{black},commentstyle=\color{gray}\ttfamily\itshape,stringstyle=\color[rgb]{0,0,0.5},columns=fullflexible,alsoletter=.,texcl=true,escapeinside={*@}{@*)},escapebegin=\lst@commentstyle\,,breaklines=true,breakatwhitespace=false,numbers=left,numberstyle=\ttfamily\tiny\color{gray},stepnumber=1,numbersep=10pt,backgroundcolor=\color{white},tabsize=4,showspaces=false,showstringspaces=false,xleftmargin=.23in,frame=lines
,rulesepcolor=\color[rgb]{0.85,0.85,0.85},basewidth={0.5em,0.42em},language=r,label=
,caption= ,captionpos=b}
\lstset{basicstyle=\ttfamily\small,keywordstyle=\color{black},commentstyle=\color{gray}\ttfamily\itshape,stringstyle=\color[rgb]{0,0,0.5},columns=fullflexible,alsoletter=.,texcl=true,escapeinside={*@}{@*)},escapebegin=\lst@commentstyle\,,breaklines=true,breakatwhitespace=false,numbers=left,numberstyle=\ttfamily\tiny\color{gray},stepnumber=1,numbersep=10pt,backgroundcolor=\color{white},tabsize=4,showspaces=false,showstringspaces=false,xleftmargin=.23in,frame=lines
,rulesepcolor=\color[rgb]{0.85,0.85,0.85},basewidth={0.5em,0.42em},language=python,label=
,caption= ,captionpos=b}
\author{Klaus Kähler Holst}
\date{\today}
\title{Estimating partial correlations with \texttt{lava}}
\hypersetup{
 pdfauthor={Klaus Kähler Holst},
 pdftitle={Estimating partial correlations with \texttt{lava}},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3.6)},
 pdflang={English}}
\begin{document}

\maketitle
\noindent\rule{\textwidth}{0.5pt}


This document illustrates how to estimate partial correlation
coefficients using \texttt{lava}.


\vspace*{2em}

Assume that \(Y_{1}\) and \(Y_{2}\) are conditionally normal
distributed given \(\bm{X}\) with the following linear structure
\begin{gather}\label{eq:model1}
  \begin{split}
    Y_1 = \bm{\beta}_1^{t}\bm{X} + \epsilon_1 \\
    Y_2 = \bm{\beta}_2^{t}\bm{X} + \epsilon_2
\end{split}
\end{gather}
with covariates \(\bm{X} = (X_1,\ldots,X_k)^{t}\) and measurement errors
\begin{align*}
  \begin{pmatrix}
    \epsilon_{1} \\
    \epsilon_{2}
  \end{pmatrix} \sim \mathcal{N}\left(0, \bm{\Sigma} \right), \quad \bm{\Sigma}
    =
    \begin{pmatrix}
      \sigma_1^2 & \rho\sigma_{1}\sigma_{2} \\
      \rho\sigma_{1}\sigma_{2} & \sigma_2^2
    \end{pmatrix}.
\end{align*}


\begin{center}
\usetikzlibrary{shapes,arrows,shadows,shadows.blur}
\tikzstyle{plain}=[rectangle,thick,fill=white,align=left, minimum size=1cm,draw=gray!80,blur shadow={shadow blur steps=5}]
\begin{tikzpicture}[scale=0.6]
	\matrix[row sep=2em,column sep=0.3cm,ampersand replacement=\&]{
	  \node(y1) [plain] {$Y_{1}$}; \& \& \node(y2) [plain] {$Y_{2}$}; \\
	  \& \node(x) [plain] {$X$}; \\
	};
	\path[<->] (y1) edge[thick,dashed,bend left=20] node [above] {$\rho$} (y2) ; %% left,rigth,above,below
	\path[->] (x) edge[thick] node [left] {$\beta_{1}$} (y1);
	\path[->] (x) edge[thick] node [right] {$\beta_{2}$} (y2);
  \end{tikzpicture}
\end{center}

Here we focus on inference with respect to the correlation parameter \(\rho\).

\vspace*{2em}

\section{Simulation}
\label{sec:orgcdbb6eb}

As an example, we will simulate data from this model with a single covariate. First we load the necessary libraries:

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
library('lava')
library('mets')
library('magrittr')
\end{lstlisting}
The model can be specified (here using the pipe notation via \texttt{magrittr})
with the following syntax where the correlation parameter here is
given the label '\texttt{r}':
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m0 <- lvm() %>%
  covariance(y1 ~ y2, value='r') %>%
  regression(y1 + y2 ~ x)
\end{lstlisting}

To simulate from the model we can now simply use the \texttt{sim} method. The
parameters of the models are set through the argument \texttt{p} which must be a
named numeric vector of parameters of the model. The parameter names
can be inspected with the \texttt{coef} method
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
coef(m0, labels=TRUE)
\end{lstlisting}

\begin{verbatim}
  m1       m2       p1       p2       p3       p4       p5
"y1"     "y2"   "y1~x"   "y2~x" "y1~~y1" "y2~~y2"      "r"
\end{verbatim}


The default simulation parameters are zero for all intercepts (\texttt{y1}, \texttt{y2})
and one for all regression coefficients (\texttt{y1\textasciitilde{}x}, \texttt{y2\textasciitilde{}x}) and residual
variance parameters (\texttt{y1\textasciitilde{}\textasciitilde{}y1}, \texttt{y2\textasciitilde{}\textasciitilde{}y2}).

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
d <- sim(m0, 500, p=c(r=0.9), seed=1)
head(d)
\end{lstlisting}

\begin{verbatim}

          y1         y2           x
1  0.6452154  0.8677628  1.13496509
2  1.1098723  0.9579211  1.11193185
3 -2.2072258 -2.3171509 -0.87077763
4  1.5684365  1.0675354  0.21073159
5  0.8752209  1.0845932  0.06939565
6 -1.5113072 -0.7477956 -1.66264885
\end{verbatim}


Under Gaussian and coarsening at random assumptions we can also
consistently estimate the correlation in the presence of censoring or
missing data. To illustrate this, we add left and right censored data
types to the model output using the \texttt{transform} method.

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
cens1 <- function(threshold,type='right') {
  function(x) {
    x <- unlist(x)
    if (type=='left')
      return( Surv(pmax(x,threshold), x>=threshold, type='left') )
    return ( Surv(pmin(x,threshold), x<=threshold) )
  }
}

m0 %<>%
  transform(s1 ~ y1, cens1(-2, 'left')) %>%
  transform(s2 ~ y2, cens1(2,  'right'))
\end{lstlisting}

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
d <- sim(m0, 500, p=c(r=0.9), seed=1)
head(d)
\end{lstlisting}

\begin{verbatim}

          y1         y2           x          s1         s2
1  0.6452154  0.8677628  1.13496509   0.6452154  0.8677628
2  1.1098723  0.9579211  1.11193185   1.1098723  0.9579211
3 -2.2072258 -2.3171509 -0.87077763 -2.0000000- -2.3171509
4  1.5684365  1.0675354  0.21073159   1.5684365  1.0675354
5  0.8752209  1.0845932  0.06939565   0.8752209  1.0845932
6 -1.5113072 -0.7477956 -1.66264885  -1.5113072 -0.7477956
\end{verbatim}


\section{Estimation and inference}
\label{sec:org389847a}

The Maximum Likelihood Estimate can be obtainted using the \texttt{estimate} method:

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m <- lvm() %>%
     regression(y1 + y2 ~ x) %>%
     covariance(y1 ~ y2)

e <- estimate(m, data=d)
e
\end{lstlisting}

\begin{verbatim}

                    Estimate Std. Error  Z-value  P-value
Regressions:
   y1~x              0.93300    0.04443 20.99871   <1e-12
    y2~x             0.91652    0.04527 20.24500   <1e-12
Intercepts:
   y1               -0.00541    0.04482 -0.12076   0.9039
   y2               -0.02715    0.04566 -0.59457   0.5521
Residual Variances:
   y1                1.00419    0.06351 15.81139
   y1~~y2            0.91221    0.06130 14.88041   <1e-12
   y2                1.04252    0.06593 15.81139
\end{verbatim}

The estimate \texttt{y1\textasciitilde{}\textasciitilde{}y2} gives us the estimated covariance between the
residual terms in the model. To estimate the correlation we can apply
the delta method using the \texttt{estimate} method again

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e, function(p) p['y1~~y2']/(p['y1~~y1']*p['y2~~y2'])^.5)
\end{lstlisting}

\begin{verbatim}
       Estimate  Std.Err   2.5%  97.5% P-value
y1~~y2   0.8915 0.008703 0.8745 0.9086       0
\end{verbatim}


Alternatively, the correlations can be extracted using the \texttt{correlation} method
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
correlation(e)
\end{lstlisting}

\begin{verbatim}
      Estimate Std.Err   2.5%  97.5%   P-value
y1~y2   0.8915         0.8721 0.9082 3.58e-224
\end{verbatim}



Note, that in this case the confidence intervals are constructed
by using a variance stabilizing transformation, Fishers
\(z\)-transform \citep{MR2135927},
\newcommand{\arctanh}{\operatorname{arctanh}}
\begin{align*}
  z = \arctanh(\widehat{\rho}) =
  \frac{1}{2}\log\left(\frac{1+\widehat{\rho}}{1-\widehat{\rho}}\right)
\end{align*}
where \(\widehat{\rho}\) is the MLE.  This estimate has an approximate
asymptotic normal distribution
\(\mathcal{N}(\arctanh(\rho),\frac{1}{n-3-k})\). Hence a asymptotic 95\%
confidence interval is given by
\begin{align*}
  \widehat{z} \pm \frac{1.96}{\sqrt{n-3-k}}
\end{align*}
and the confidence interval for \(\widehat{\rho}\) can directly be calculated by
the inverse transformation:
\begin{align*}
  \widehat{\rho} = \tanh(z) = \frac{e^{2z}-1}{e^{2z}+1}.
\end{align*}

This is equivalent to the direct calculations using the delta method
(except for the small sample bias correction \(3+k\)) where the
estimate and confidence interval are transformed back to the original
scale using the \texttt{back.transform} argument.
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e, function(p) atanh(p['y1~~y2']/(p['y1~~y1']*p['y2~~y2'])^.5), back.transform=tanh)
\end{lstlisting}

\begin{verbatim}
       Estimate Std.Err   2.5%  97.5%    P-value
y1~~y2   0.8915         0.8732 0.9074 7.445e-249
\end{verbatim}


The transformed confidence interval will generally have improved
coverage especially near the boundary \(\rho \approx \pm 1\).


While the estimates of this particular model can be obtained in closed
form, this is generally not the case when for example considering
parameter constraints, latent variables, or missing and censored
observations. The MLE is therefore obtained using iterative
optimization procedures (typically Fisher scoring or Newton-Raphson
methods). To ensure that the estimated variance parameters leads to a
meaningful positive definite structure and to avoid potential problems
with convergence it can often be a good idea to parametrize the model
in a way that such parameter constraints are naturally fulfilled.
This can be achieved with the \texttt{constrain} method.

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m2 <- m %>%
    parameter(~ l1 + l2 + z) %>%
    variance(~ y1 + y2, value=c('v1','v2')) %>%
    covariance(y1 ~ y2, value='c') %>%
    constrain(v1 ~ l1, fun=exp) %>%
    constrain(v2 ~ l2, fun=exp) %>%
    constrain(c ~ z+l1+l2, fun=function(x) tanh(x[1])*sqrt(exp(x[2])*exp(x[3])))
\end{lstlisting}

In the above code,  we first add new parameters \texttt{l1} and \texttt{l2} to hold the log-variance
parameters, and \texttt{z} which will be the z-transform of the correlation
parameter.
Next we label the variances and covariances: The variance of \texttt{y1} is called \texttt{v1};
the variance of \texttt{y2} is called \texttt{v2}; the covariance of \texttt{y1} and \texttt{y2} is called \texttt{c}.
Finally, these parameters are tied to the previously defined
parameters using the \texttt{constrain} method such that \texttt{v1} := \(\exp(\mathtt{l1})\),
\texttt{v2} := \(\exp(\mathtt{l1})\) and \texttt{z} := \(\tanh(\mathtt{z})\sqrt{\mathtt{v1}\mathtt{v2}}\)

In this way there is no
constraints on the actual estimated parameters \texttt{l1}, \texttt{l2}, and \texttt{z} which can
take any values in \(\R^{3}\), while we at the same time are
guaranteed a proper covariance matrix which is positive definite.


\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
e2 <- estimate(m2, d)
e2
\end{lstlisting}

\begin{verbatim}

                       Estimate Std. Error  Z-value  P-value
Regressions:
   y1~x                 0.93300    0.04443 20.99871   <1e-12
    y2~x                0.91652    0.04527 20.24500   <1e-12
Intercepts:
   y1                  -0.00541    0.04482 -0.12076   0.9039
   y2                  -0.02715    0.04566 -0.59457   0.5521
Additional Parameters:
   l1                   0.00418    0.06325  0.06617   0.9472
   l2                   0.04164    0.06325  0.65832   0.5103
   z                    1.42942    0.04472 31.96286   <1e-12
\end{verbatim}

The correlation coefficient can then be obtained as

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e2, 'z', back.transform=tanh)
\end{lstlisting}

\begin{verbatim}
    Estimate Std.Err   2.5%  97.5%    P-value
[z]   0.8915         0.8729 0.9076 5.606e-243

 Null Hypothesis:
  [z] = 0
\end{verbatim}



In practice, a much shorter syntax can be used to obtain the above
parametrization. We can simply use the argument \texttt{constrain}
when specifying the covariances (the argument \texttt{rname} specifies the
parameter name of the \(\arctanh\) transformed correlation
coefficient, and \texttt{lname}, \texttt{lname2} can be used to specify the parameter
names for the log variance parameters):
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m2 <- lvm() %>%
  regression(y1 + y2 ~ x) %>%
  covariance(y1 ~ y2, constrain=TRUE, rname='z')

e2 <- estimate(m2, data=d)
e2
\end{lstlisting}

\begin{verbatim}

                       Estimate Std. Error  Z-value  P-value
Regressions:
   y1~x                 0.93300    0.04443 20.99871   <1e-12
    y2~x                0.91652    0.04527 20.24500   <1e-12
Intercepts:
   y1                  -0.00541    0.04482 -0.12076   0.9039
   y2                  -0.02715    0.04566 -0.59457   0.5521
Additional Parameters:
   l1                   0.00418    0.06325  0.06617   0.9472
   l2                   0.04164    0.06325  0.65832   0.5103
   z                    1.42942    0.04472 31.96286   <1e-12
\end{verbatim}

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e2, 'z', back.transform=tanh)
\end{lstlisting}

\begin{verbatim}
    Estimate Std.Err   2.5%  97.5%    P-value
[z]   0.8915         0.8729 0.9076 5.606e-243

 Null Hypothesis:
  [z] = 0
\end{verbatim}




As an alternative to the Wald confidence intervals (with or without
transformation) is to profile the likelihood. The profile likelihood
confidence intervals can easily be obtained with the \texttt{confint} method:
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
tanh(confint(e2, 'z', profile=TRUE))
\end{lstlisting}

\begin{verbatim}
      2.5 %    97.5 %
z 0.8720834 0.9081964
\end{verbatim}



Finally, a non-parametric bootstrap can be calculated in the following way
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
b <- bootstrap(e2, data=d, R=1000, mc.cores=4)
b
\end{lstlisting}

\begin{verbatim}

Non-parametric bootstrap statistics (R=1000):

     Estimate      Bias          Std.Err       2.5 %         97.5 %
y1   -0.0054119135  0.0019882525  0.0452024023 -0.0930118970  0.0818160752
y2   -0.0271494916  0.0025699085  0.0465362695 -0.1168908519  0.0666351002
y1~x  0.9330043509 -0.0008669356  0.0482877083  0.8420147683  1.0283778461
y2~x  0.9165185250 -0.0012522823  0.0473981272  0.8227371020  1.0094390648
l1    0.0041846522 -0.0043979105  0.0608335861 -0.1168814057  0.1230780830
l2    0.0416361064 -0.0042215107  0.0590866613 -0.0752208005  0.1555967981
z     1.4294227075  0.0013286462  0.0421139954  1.3484001202  1.5162645070
v1    1.0041934200 -0.0025531270  0.0611711794  0.8896906996  1.1309727308
v2    1.0425150452 -0.0025827313  0.0613581744  0.9275386968  1.1683550254
c1    0.9122097189 -0.0022165115  0.0573649392  0.8065011182  1.0302001285
\end{verbatim}

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
quantile(tanh(b$coef[,'z']), c(.025,.975))
\end{lstlisting}

\begin{verbatim}
     2.5%     97.5%
0.8736751 0.9080445
\end{verbatim}


\subsection{Censored observations}
\label{sec:orgdaa7f36}

Letting one of the variables be right-censored (Tobit-type model) we
can proceed in exactly the same way\footnote{This functionality is only
available with the \texttt{mets} package installed (available from CRAN)}. The
only difference is that the variables that are censored must all be
defined as \texttt{Surv} objects (from the \texttt{survival} package which is
automatically loaded when using the \texttt{mets} package).

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m3 <- lvm() %>%
  regression(y1 + s2 ~ x) %>%
  covariance(y1 ~ s2, constrain=TRUE, rname='z')

e3 <- estimate(m3, d)
e3
\end{lstlisting}

\begin{verbatim}

                       Estimate Std. Error  Z-value  P-value
Regressions:
   y1~x                 0.93301    0.04443 20.99884   <1e-12
    s2~x                0.92402    0.04643 19.90118   <1e-12
Intercepts:
   y1                  -0.00541    0.04482 -0.12081   0.9038
   s2                  -0.02119    0.04638 -0.45684   0.6478
Additional Parameters:
   l1                   0.00418    0.06325  0.06607   0.9473
   l2                   0.06318    0.06492  0.97313   0.3305
   z                    1.42834    0.04546 31.41832   <1e-12
\end{verbatim}

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e3, 'z', back.transform=tanh)
\end{lstlisting}

\begin{verbatim}
    Estimate Std.Err  2.5%  97.5%    P-value
[z]   0.8913         0.872 0.9079 1.503e-226

 Null Hypothesis:
  [z] = 0
\end{verbatim}



And here the same analysis with \texttt{s1} being left-censored and \texttt{s2} right-censored:
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
m3b <- lvm() %>%
  regression(s1 + s2 ~ x) %>%
  covariance(s1 ~ s2, constrain=TRUE, rname='z')

e3b <- estimate(m3b, d)
e3b
\end{lstlisting}

\begin{verbatim}

                       Estimate Std. Error  Z-value  P-value
Regressions:
   s1~x                 0.92834    0.04479 20.72738   <1e-12
    s2~x                0.92466    0.04648 19.89510   <1e-12
Intercepts:
   s1                  -0.00233    0.04492 -0.05196   0.9586
   s2                  -0.02083    0.04641 -0.44874   0.6536
Additional Parameters:
   l1                  -0.00076    0.06500 -0.01163   0.9907
   l2                   0.06425    0.06498  0.98869   0.3228
   z                    1.42627    0.04609 30.94303   <1e-12
\end{verbatim}

\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
estimate(e3b, 'z', back.transform=tanh)
\end{lstlisting}

\begin{verbatim}
    Estimate Std.Err   2.5%  97.5%    P-value
[z]   0.8909         0.8713 0.9077 8.962e-222

 Null Hypothesis:
  [z] = 0
\end{verbatim}


\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
tanh(confint(e3, 'z', profile=TRUE))
\end{lstlisting}

\begin{verbatim}
      2.5 %    97.5 %
z 0.8714569 0.9082484
\end{verbatim}


\section*{SessionInfo}
\label{sec:org4826622}
\lstset{numbers=left,numberstyle=\ttfamily\tiny\color{gray},language=r,label= ,caption= ,captionpos=b}
\begin{lstlisting}
sessionInfo()
\end{lstlisting}

\begin{verbatim}
R version 3.6.3 (2020-02-29)
Platform: x86_64-redhat-linux-gnu (64-bit)
Running under: Fedora 32 (Workstation Edition)

Matrix products: default
BLAS/LAPACK: /usr/lib64/libopenblas-r0.3.9.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C
 [9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C

attached base packages:
[1] stats     grDevices utils     datasets  graphics  methods   base

other attached packages:
[1] magrittr_1.5    mets_1.2.7.1    timereg_1.9.4   survival_3.1-12
[5] lava_1.6.8

loaded via a namespace (and not attached):
[1] compiler_3.6.3      Matrix_1.2-18       tools_3.6.3
[4] Rcpp_1.0.4.6        mvtnorm_1.1-0       splines_3.6.3
[7] grid_3.6.3          numDeriv_2016.8-1.1 lattice_0.20-41
\end{verbatim}


\bibliographystyle{unsrtnat}
\bibliography{ref}
\end{document}